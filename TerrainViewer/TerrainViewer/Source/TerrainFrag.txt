#version 400
struct DirectionalLight
{
	vec3 color;
	float ambientIntensity;
	vec3 dir;
	float diffuseIntensity;
};

// Out data
out vec4 out_Color;

// In data
in float defaultHeight;
smooth in vec3 vertNormal;
smooth in vec3 halfDir;
in DirectionalLight light;
in vec2 snowUV;
in vec2 rockUV;
in vec2 grassUV;

//enum RenderState{
//	AMBIENT_RENDER_STATE	= 0,
//	DIFFUSE_RENDER_STATE	= 1,
//	SPEC_RENDER_STATE		= 2,
//	PHONG_RENDER_STATE		= 3,
//	NORMALS_RENDER_STATE	= 4,
//	RENDER_STATE_COUNT		= 5
//};

uniform int renderState;
uniform sampler2D snow;
uniform sampler2D rock;
uniform sampler2D grass;


vec4 BlinnPhongColor( vec3 norm, vec3 halfV, bool _hasSnow )
{
	vec4 retColor = vec4(0,0,0,0);
	if( renderState == 3
		|| renderState == 0 )
	{
		vec4 ambientColor = vec4(light.color * light.ambientIntensity, 0.0f);
		retColor += ambientColor;
	}

	if( renderState == 3
		|| renderState == 1 )
	{
		vec4 diffuseColor = vec4(0,0,0,0);
		float diffuseFactor = max(dot(norm, normalize(-light.dir)), 0.0);
		diffuseColor = vec4(light.color, 0) * light.diffuseIntensity * diffuseFactor;
		retColor += diffuseColor;
	}

	if( renderState == 3
		|| renderState == 2 )
	{
		if(_hasSnow)
		{
			float nDotH = max(dot(norm, halfV),0.0f);

			// First value is the hard-coded value for the material's shininess factor
			float specColor = pow(nDotH, 10.f);
			retColor += vec4(vec3(.5f,.5f,.5f) * specColor, 0);
		}
	}
	return retColor;
}

vec4 PhongColor( vec3 norm )
{
	vec4 ambientColor = vec4(light.color * light.ambientIntensity, 1);
	vec4 diffuseColor = vec4(0,0,0,0);

	float diffuseFactor = max( dot(norm, normalize(-light.dir)), 0.0f);
	diffuseColor = vec4(light.color, 1.0f) * light.diffuseIntensity * diffuseFactor;

	vec4 retColor = diffuseColor + ambientColor;

	return clamp(retColor, 0.0, 1.0);
}

vec4 TextureColors(float normY, inout bool _hasSnow)
{
	// .1f is a hardcoded hack. We should upload the max height in case we change it
	float heightPct = defaultHeight / .1f;
	vec4 retColor = vec4(0,0,0,0);

	// snow color will be based on height
	float snowIntensity = heightPct > .55f ? 1.0f : 0.0f;
	retColor += vec4(texture2D(snow, snowUV).rgb, 1.0f)
					* snowIntensity;

	// grass color will be based on height
	float grassIntensity = heightPct <= .55f ? 1.0f : 0.0f;
	retColor += vec4(texture2D(grass, grassUV).rgb, 1.0f) 
					* grassIntensity;

	// rock color will be based on normal
	float rockIntensity = normY < 0.91f ? 1.0f: 0.0f;
	if( rockIntensity > 0)
	{
		retColor = vec4(texture2D(rock, rockUV).rgb, 1.0f)
						* rockIntensity;
	}
	_hasSnow = snowIntensity > 0 && rockIntensity == 0;
	return retColor;
}

bool hasSnow = false;
void main(void)
{
	vec3 newNorm = normalize(vertNormal);
	vec3 newHalfV = normalize(halfDir);
	out_Color = TextureColors(newNorm.y, hasSnow);
    out_Color *= BlinnPhongColor( newNorm, newHalfV, hasSnow );
	if(renderState == 4)
	{
		//Render normals of each frag via color
		out_Color = vec4((newNorm + vec3(1,1,1)) * .5, 1);
	}
}
