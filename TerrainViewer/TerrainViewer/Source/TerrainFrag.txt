#version 400
struct DirectionalLight
{
	vec3 color;
	float ambientIntensity;
	vec3 dir;
	float diffuseIntensity;
};

// Out data
out vec4 out_Color;

// In data
in float defaultHeight;
smooth in vec3 vertNormal;
smooth in vec3 halfDir;
in DirectionalLight light;
in vec2 snowUV;
in vec2 rockUV;
in vec2 grassUV;

//enum RenderState{
//	AMBIENT_RENDER_STATE	= 0,
//	DIFFUSE_RENDER_STATE	= 1,
//	SPEC_RENDER_STATE		= 2,
//	PHONG_RENDER_STATE		= 3,
//	NORMALS_RENDER_STATE	= 4,
//	RENDER_STATE_COUNT		= 5
//};

uniform int renderState;
uniform sampler2D snow;
uniform sampler2D rock;
uniform sampler2D grass;


vec4 BlinnPhongColor( vec3 norm, vec3 halfV, bool _hasSnow, float _snowFactor )
{
	vec4 retColor = vec4(0,0,0,0);

	//-----------------------------------------------------------------------------------------
	// AMBIENT COLOR CALCULATION
	if( renderState == 3
		|| renderState == 0 )
	{
		vec4 ambientColor = vec4(light.color * light.ambientIntensity, 0.0f);
		retColor += ambientColor;
	}

	//-----------------------------------------------------------------------------------------
	// DIFFUSE COLOR CALCULATION
	if( renderState == 3
		|| renderState == 1 )
	{
		vec4 diffuseColor = vec4(0,0,0,0);
		float diffuseFactor = max(dot(norm, normalize(-light.dir)), 0.0);
		diffuseColor = vec4(light.color, 0) * light.diffuseIntensity * diffuseFactor;
		retColor += diffuseColor;
	}

	//-----------------------------------------------------------------------------------------
	// SPECULAR COLOR CALCULATION
	if( renderState == 3
		|| renderState == 2 )
	{
		if(_hasSnow)
		{
			float nDotH = max(dot(norm, halfV),0.0f);

			float specColor = pow(nDotH, 5.f);
			// First value is the hard-coded value for the material's shininess factor
			retColor += vec4(vec3(.8f,.8f,.8f) * _snowFactor * specColor, 0);
		}
	}
	return retColor;
}

vec4 TextureColors(float normY, inout bool _hasSnow, inout float _snowFactor)
{
	// Thresholds
	float minThreshSnow = .54f;
	float threshFullSnow = .56f;
	float minThreshRock = .91f;
	float threshFullRock = .88f;

	// Texture colors
	vec4 rockColor = texture2D(rock, rockUV);
	vec4 snowColor = texture2D(snow, snowUV);
	vec4 grassColor = texture2D(grass, grassUV);

	//-----------------------------------------------------------------------------------------
	// Texture blending
	// HACK .1f is a hardcoded hack. We should upload the max height in case we change it
	float heightPct = defaultHeight / .1f;
	vec4 retColor = vec4(0,0,0,0);

	float rockLerpVal = ( normY - minThreshRock ) / (threshFullRock - minThreshRock);
	rockLerpVal = max( 0.0f, min( rockLerpVal, 1.f ) );
	
	float snowLerpVal = (heightPct - minThreshSnow) / (threshFullSnow - minThreshSnow);
	snowLerpVal = max( 0.0f, min( snowLerpVal, 1.f ) );

	retColor = mix( grassColor, snowColor, snowLerpVal );
	retColor = mix( retColor, rockColor, rockLerpVal );

	_hasSnow = snowLerpVal > rockLerpVal;
	_snowFactor = snowLerpVal - rockLerpVal;
	retColor.a = 1;
	return retColor;
}

bool hasSnow = false;
float snowFactor = 0.0f;
void main(void)
{
	// Normal and half vector (blinn-phong) need to be normalized after
	// being passed from vertShader because they are being interpolated
	vec3 newNorm = normalize(vertNormal);
	vec3 newHalfV = normalize(halfDir);
	
	// Get texture colors then use BlinnPhong calculation to get realistic lighting
	out_Color = TextureColors(newNorm.y, hasSnow, snowFactor);
    out_Color *= BlinnPhongColor( newNorm, newHalfV, hasSnow, snowFactor );
	out_Color.a = 1;
	if(renderState == 4)
	{
		//Render normals of each frag via color
		out_Color = vec4((newNorm + vec3(1,1,1)) * .5, 1);
	}
}
